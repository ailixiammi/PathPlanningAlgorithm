### 1 基于搜索算法

#### 1.1 Dijkstra

**算法描述：**

​	Dijkstra算法是一种经典的**单源**最短路径算法，用于在加权图中找到从一个源点到所有其他顶点的最短路径。适用于**无负权边**的图。

​	在使用优先级队列优化的情况下，时间复杂度为**O(nlogn)**

**算法步骤：**

```
Dijkstra(Graph, source):
    初始化：
        对于每个顶点v ∈ Graph:
            dist[v] = INF
            visited[v] = false
        dist[source] = 0
        创建优先队列pq，并将源点(source, 0)加入pq

    主循环：
        当pq非空时:
            u = 从pq中取出具有最小dist值的顶点
            如果visited[u]为true，则跳过当前循环
            visited[u] = true
            对于每个与u相邻的顶点v:
                alt = dist[u] + weight(u, v)
                如果alt < dist[v]:
                    dist[v] = alt
                    将(v, alt)加入pq

    返回dist数组
```

**代码实现：**

​	`Dijkstra.cpp, Dijkstra2.cpp`

---

#### 1.2 Astar

Astar算法是一种**启发式搜索算法**，广泛用于路径查找和图遍历问题。它结合了Dijkstra算法的最短路径思想和启发式搜索的效率，能够快速找到从起点到终点的最优路径。A*算法特别适用于有明确目标的搜索问题，如游戏中的寻路、机器人路径规划等。

**算法描述:**

**输入**

- 一个加权图，图中的边权重非负。
- 起点（起点）。
- 终点（目标点）。
- 启发式函数`h(n)`，用于估计从节点`n`到终点的代价。

**输出**

- 从起点到终点的最短路径。
- 路径的总代价。

**算法原理：**

A*算法的核心在于它使用了一个启发式函数`h(n)`来估计从当前节点`n`到终点的代价，同时结合了实际代价`g(n)`来评估节点的优先级。每个节点的优先级由以下公式计算： *f*(*n*)=*g*(*n*)+*h*(*n*)

- **`g(n)`**：从起点到当前节点`n`的实际代价。
- **`h(n)`**：从当前节点`n`到终点的估计代价（启发式函数）。
- **`f(n)`**：节点的总代价，用于评估节点的优先级。

A*算法通过优先队列（通常是最小堆）来管理待处理的节点，每次选择`f(n)`值最小的节点进行扩展，直到找到终点。

**算法步骤**：

```plaintext
AStar(Graph, start, goal):
    初始化：
        对于每个节点n ∈ Graph:
            g[n] = INF
            f[n] = INF
        g[start] = 0
        f[start] = h(start)
        创建优先队列openSet，并将起点(start, f[start])加入openSet
        创建集合closedSet，用于存储已处理的节点

    主循环：
        当openSet非空时:
            current = 从openSet中取出f值最小的节点
            如果current == goal:
                返回重建的路径
            将current加入closedSet
            对于每个与current相邻的节点neighbor:
                如果neighbor在closedSet中:
                    跳过当前节点
                临时代价temp_g = g[current] + weight(current, neighbor)
                如果neighbor不在openSet中，或者temp_g < g[neighbor]:
                    来源[neighbor] = current
                    g[neighbor] = temp_g
                    f[neighbor] = g[neighbor] + h(neighbor)
                    如果neighbor不在openSet中:
                        将neighbor加入openSet

    返回失败（未找到路径）
```

**启发式函数：**

启发式函数`h(n)`是Astar算法的关键部分，它需要满足以下条件：

- **可接受性**：**`h(n)`必须小于或等于从`n`到终点的实际代价**。这确保了算法能够找到最优解。
- **单调性**：对于任何节点`n`和它的邻居`m`，`h(n)`必须满足： *h*(*n*)≤*d*(*n*,*m*)+*h*(*m*) 其中`d(n, m)`是从`n`到`m`的实际代价。

常见的启发式函数包括：

- **欧几里得距离**：适用于**二维平面**上的路径规划。 *h*(*n*)=(*x**n*−*x**g**o**a**l*)2+(*y**n*−*y**g**o**a**l*)2
- **曼哈顿距离**：适用于**网格地图**。 *h*(*n*)=∣*x**n*−*x**g**o**a**l*∣+∣*y**n*−*y**g**o**a**l*∣
- **零启发式**：`h(n) = 0`，此时A*算法退化为Dijkstra算法。

**算法优缺点：**

**优点**

1. **效率高**：通过启发式函数`h(n)`，Astar算法能够快速找到目标，避免了不必要的搜索。
2. **保证最优解**：只要启发式函数满足可接受性和单调性，Astar算法能够找到从起点到终点的最优路径。
3. **灵活性高**：通过选择不同的启发式函数，Astar算法可以适应不同的应用场景。

**缺点**

1. **启发式函数的选择**：启发式函数的设计需要根据具体问题进行调整，不恰当的启发式函数可能导致算法效率低下或无法找到最优解。
2. **内存消耗大**：Astar算法需要存储所有待处理的节点和已处理的节点，对于大型图，可能会占用较多内存。
3. **不适用于动态环境**：如果图的结构或权重在搜索过程中发生变化，Astar算法可能需要重新计算。

---

### 2 基于采样的算法

2.1 PRM

2.2 RRT

2.3 RRTstar

3 基于运动学的算法

